>>> from dsn.s_expr.from_python import s_expr_from_python
>>> from dsn.form_analysis.structure import ValueForm, VariableForm, DefineForm, LambdaForm, SequenceForm
>>> from dsn.form_analysis.structure import FormList, Symbol, SymbolList

>>> from dsn.form_analysis.lexical_addressing_x import lexical_addressing_x, find_lambda_children, some_lambda_tree
>>> from dsn.form_analysis.from_s_expr import from_s_expr

>>> the_lambda = from_s_expr(s_expr_from_python(
... ("lambda", ("param",), ("define", "definition", "a"),
...                        ("b",),
...                        ("param",),
...                        ("definition",))))

>>> the_context = {'a': None, 'b': 2}

>>> sorted(lexical_addressing_x(the_context, the_lambda).items())
[('a', None), ('b', 3), ('definition', 0), ('param', 0)]

>>> nested_lambdas = from_s_expr(s_expr_from_python(
... ("begin",
...     ("lambda", (), ("lambda", (), "1"),
...                    ("begin",
...                        ("lambda", (), ("lambda", (), "2"),),),),)))

>>> find_lambda_children(nested_lambdas)
[(lambda () (lambda () 1) (begin (lambda () (lambda () 2))))]

>>> find_lambda_children(nested_lambdas.sequence.the_list[0].body.the_list[0])
[(lambda () 1)]

>>> find_lambda_children(nested_lambdas.sequence.the_list[0].body.the_list[1])
[(lambda () (lambda () 2))]

>>> some_lambda_tree(nested_lambdas.sequence.the_list[0])
(L [(L []), (L [(L [])])])


The recursion as defined in the examples below is non-sensical from the perspective of evaluation (i.e. in a real-life
example the dependency on other variables would more likely be wrapped in both a lambda and an if-expression) but it's
the simplest thing for the question at hand (that of static dependency analysis).


These examples work on a single scope:

>>> single_scope = s_expr_from_python(("lambda", (),
...     ("define", "a", "9"),
...     ("define", "rec", "rec"),
...     ("define", "mut-rec-a", "mut-rec-b"),
...     ("define", "mut-rec-b", "mut-rec-a"),
... ))

This is an example that shows cross-scope deps; it also demonstrates the shadowing of "y"

>>> scope_in_scope = s_expr_from_python(("lambda", (), (
...     ("define", "x", ("lambda", ("y",),
...         ("ignore-args", "x", "y"))),
...     ("define", "ignore-args", ("lambda", ("a", "b",), "0")),
...     ("define", "y", "8"),
... )))
