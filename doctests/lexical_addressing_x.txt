>>> from dsn.s_expr.from_python import s_expr_from_python
>>> from dsn.form_analysis.structure import ValueForm, VariableForm, DefineForm, LambdaForm, SequenceForm
>>> from dsn.form_analysis.structure import FormList, Symbol, SymbolList

>>> from dsn.form_analysis.lexical_addressing_x import lexical_addressing_x, find_lambda_children, some_lambda_tree

>>> the_lambda = LambdaForm(
...         SymbolList([Symbol("param")]),
...         FormList([
...             DefineForm(Symbol("definition"), VariableForm(Symbol("a"))),
...             VariableForm(Symbol("b")),
...             VariableForm(Symbol("param")),
...             VariableForm(Symbol("definition")),
...         ]))

>>> the_context = {'a': None, 'b': 2}

>>> sorted(lexical_addressing_x(the_context, the_lambda).items())
[('a', None), ('b', 3), ('definition', 0), ('param', 0)]

>>> nested_lambdas = SequenceForm(FormList([
...             LambdaForm(SymbolList([]), FormList([
...                 LambdaForm(SymbolList([]), FormList([])),
...                 SequenceForm(FormList([LambdaForm(SymbolList([]), FormList([
...                     LambdaForm(SymbolList([]), FormList([])),
...                 ]))])),
...             ]))
...         ]))

>>> find_lambda_children(nested_lambdas)
[(lambda () (lambda ()) (begin (lambda () (lambda ()))))]

>>> find_lambda_children(nested_lambdas.sequence.the_list[0].body.the_list[0])
[(lambda ())]

>>> find_lambda_children(nested_lambdas.sequence.the_list[0].body.the_list[1])
[(lambda () (lambda ()))]

>>> some_lambda_tree(nested_lambdas.sequence.the_list[0])
(L [(L []), (L [(L [])])])


The recursion as defined in the examples below is non-sensical from the perspective of evaluation (i.e. in a real-life
example the dependency on other variables would more likely be wrapped in both a lambda and an if-expression) but it's
the simplest thing for the question at hand (that of static dependency analysis).


These examples work on a single scope:

>>> single_scope = s_expr_from_python(("lambda", (),
...     ("define", "a", "9"),
...     ("define", "rec", "rec"),
...     ("define", "mut-rec-a", "mut-rec-b"),
...     ("define", "mut-rec-b", "mut-rec-a"),
... ))

This is an example that shows cross-scope deps; it also demonstrates the shadowing of "y"

>>> scope_in_scope = s_expr_from_python(("lambda", (), (
...     ("define", "x", ("lambda", ("y",),
...         ("ignore-args", "x", "y"))),
...     ("define", "ignore-args", ("lambda", ("a", "b",), "0")),
...     ("define", "y", "8"),
... )))
